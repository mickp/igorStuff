#pragma rtGlobals=1		// Use modern global access method.Window MAP_STMTools() : Panel	PauseUpdate; Silent 1		// building window...	NewPanel /K=1 /W=(635,300,956,415)	SetDrawLayer ProgBack	SetDrawEnv linethick= 3,linefgc= (21760,21760,21760),fillpat= 0	DrawRect 3,3,318,112	SetDrawLayer UserBack	Button UserPanelRenameButton_0,pos={40,80},size={80,20},proc=ARUserPanelButtonFunc,title="Rename"	Button UserPanelRenameButton_0,font="Arial",fColor=(61440,61440,61440)	Button UserPanelSaveButton_0,pos={140,80},size={80,20},proc=ARUserPanelButtonFunc,title="Save"	Button UserPanelSaveButton_0,userdata= A":gnHZ3^Yr.F(KB53^Ih4CisSU6uQRXD.RU,F#lU.H#.V?;Iso\\@<,jk3`U64E_p1^AScEK4%W7<:18!N3__n:?W0ou<,Z\\kF\"V0GAiiOlG%FT\\G%G2F0KT"	Button UserPanelSaveButton_0,font="Arial",fColor=(61440,61440,61440)	PopupMenu UserPanelColorPop_0,pos={220,80},size={83,22},proc=ARUserPanelPopFunc,title="Color"	PopupMenu UserPanelColorPop_0,userdata= A"5h/+\"z5h/+\"z5h/+\"z",font="Arial"	PopupMenu UserPanelColorPop_0,fSize=12	PopupMenu UserPanelColorPop_0,mode=0,popColor= (21760,21760,21760),value= #"\"*COLORPOP*\""	Button MAP_STMFlipStates,pos={259,16},size={50,50},proc=MAP_STMButtonProc,title="flip\rstates"	Button MAP_STMTrimOffset,pos={16,16},size={50,50},proc=MAP_STMButtonProc,title="trim\roffset"	Button MAP_STMPulseBias,pos={72,16},size={50,50},proc=MAP_STMButtonProc,title="pulse\rbias"	SetWindow kwTopWin,hook(AR)=UserCnTPanelHookEndMacro#pragma rtGlobals=1		// Use modern global access method.Function MAP_STMButtonProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			// click code here			String CtrlName = ReplaceString("MAP_STM", ba.CtrlName, "")			StrSwitch(CtrlName)				case "FlipStates":					MAPSTMFlipStates()				break				case "TrimOffset":					MAPSTMTrimSampleVoltage()				break			EndSwitch			break		case -1: // control being killed			break	endswitch	return 0EndFunction MAPSTMFlipStates()	//	Flips the surface bias without lifting the tip.	String LoopStr = "PidsLoop." + num2istr(ir_ReadPIDSLoop(NaN, LoopName="HeightLoop"))        	Variable s = Sign(GV("SurfaceVoltage"))    	Variable OldSetPoint = -s * (GV("CurrentSetPointAmps") - s * GV("OrcaOffset")) / GV("OrcaGain")	Variable NewSetPoint = s * (GV("CurrentSetPointAmps") + s * GV("OrcaOffset")) / GV("OrcaGain")	Variable NewSurfaceBias = GV("SurfaceBiasOffset") - GV("SurfaceVoltage")    	String ErrorStr = ""	//    Update bias and set point	ErrorStr += num2str(td_wv(LoopStr +  ".SetPoint", NewSetPoint)) + ";"	ErrorStr += num2str(td_wv("SurfaceBias", NewSurfaceBias)) + ";"	ErrorStr += num2str(td_wv(LoopStr + ".IGain", -td_rv(LoopStr + ".IGain"))) + ";"	ErrorStr += num2str(td_wv(LoopStr + ".PGain", -td_rv(LoopStr + ".PGain"))) + ";"	ErrorStr += num2str(td_wv(LoopStr + ".SGain", -td_rv(LoopStr + ".SGain"))) + ";" 	//    Update the variables wave	PV("SurfaceVoltage", -GV("SurfaceVoltage"))	ARUpdateParms("SurfaceVoltage")	ARReportError(ErrorStr)EndFunction MAPSTMTrimSampleVoltage()	//	Ideally, I'd use a jumper lead to connect Sample to ExpH# at the scanner,	//	but I can't figure out how to access those lines in the crosspoint.	//	So, for now, I average the difference between Gnd and V_sample=0 measured	//	with 5 ADCs on Cypher ... this seems to work within about 5mV, most of the time.	Variable t0	Variable delayticks = 30	String filter = "10" // Hz	String ErrorStr = ""	Make /T/FREE ADCList		//	Show a panel and suppress input.	MAPSTMMakeWorkingPanel(msg="Trimming sample bias offset.")	//	We're going to mess with crosspoint and filters, so make sure we're off the surface.	td_stop()	//	Read the crosspoint settings we'll change and save them to a wave.	Make /FREE /T /N=(5,2) XPTOriginal	XPTOriginal = {{"","","","",""}, {"InA","InB","InC", "InFastA", "InFastB"}}	ErrorStr += num2str(td_ReadMany("Cypher.Crosspoint", XPTOriginal)) + ","	//	Modify crosspoint - hook ADCs up to Ground.	Duplicate /T/FREE XPTOriginal, XPTMod	XPTMod[][0] = "Ground"	ErrorStr += num2str(td_WriteMany("Cypher.Crosspoint", XPTMod)) + ","		//	Save original filter config in a wave.	Make /FREE /T /N=(5,2) FilterOriginal	FilterOriginal = {{"", "", "", "", ""},{"A.Filter.Freq","B.Filter.Freq","C.Filter.Freq", "FastA.Filter.Freq", "FastB.Filter.Freq"}}	ErrorStr += num2str(td_ReadMany("Cypher.Input", FilterOriginal)) + ","	//	Close down the filters on our ADCs.	Duplicate /T/FREE FilterOriginal, FilterMod	FilterMod[][0] = filter	ErrorStr += num2str(td_WriteMany("Cypher.Input", FilterMod)) + ","	//	Make a wave to receive ADC readings.	Make /FREE /N=5 VGround	SetDimLabel 0,0,A,VGround	SetDimLabel 0,1,B,VGround	SetDimLabel 0,2,C,VGround	SetDimLabel 0,3,FastA,VGround	SetDimLabel 0,4,FastB, VGround			//	Wait, then read Cypher ADCs.	t0 = ticks	Do		While(ticks < t0 + delayticks)	ErrorStr += num2str(td_ReadMany("Cypher.Input", VGround)) + ","		//	Set SurfaceBias to 0	ErrorStr += num2str(td_wv("SurfaceBias", 0)) + ","	//	Hook Cypher InA, InB and InC to ContPogoOut.	XPTMod[][0] = "ContPogoOut"	ErrorStr += num2str(td_WriteMany("Cypher.Crosspoint", XPTMod)) + ","			// 	Wait, then read Cypher InA, InB and InC.	Duplicate /FREE VGround, VSamp0	t0 = ticks	Do		While(ticks < t0 + delayticks)	ErrorStr += num2str(td_ReadMany("Cypher.Input", VSamp0)) + ","	//	Clean up - put things back how they were	ErrorStr += num2str(td_WriteMany("Cypher.Crosspoint", XPTOriginal)) + ","	ErrorStr += num2str(td_WriteMany("Cypher.Input", FilterOriginal)) + ","	PV("SurfaceBiasOffset", mean(VGround) - mean(VSamp0))	ARUpdateParms("SurfaceVoltage;SurfaceBiasOffset")		MAPSTMKillWorkingPanel()	ARReportError(ErrorStr)End//	Functions for a status window.Function MAPSTMMakeWorkingPanel([msg])	String msg		If(ParamIsDefault(msg))		msg = "Doing stuff."	EndIf	NewPanel /FLT=2/K=2/N=Working /W=(320,320,660,400)	DrawText 20,32,msg	ValDisplay valdisp0,pos={20,38},size={300,18},limits={0,100,0},barmisc={0,0}	ValDisplay valdisp0,value= _NUM:0	ValDisplay valdisp0,mode= 4	SetActiveSubwindow _endfloat_	DoUpdate/W=Working/E=1		// mark this as our progress window	SetWindow Working,hook(spinner)= MAPFastCaptureUpdateWorkingEndFunction MAPSTMKillWorkingPanel()	KillWindow WorkingEndFunction MAPSTMUpdateWorking(s)		STRUCT WMWinHookStruct &s	if( s.eventCode == 23 )		ValDisplay valdisp0,value= _NUM:1,win=Working		DoUpdate/W=Working		if( V_Flag == 2 )	// we only have one button and that means abort			KillWindow $s.winName			return 1		endif	endif	return 0End